/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2406                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volVectorField;
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

dimensions      [0 1 -1 0 0 0 0];

internalField   uniform (0 0 0);

boundaryField
{
//############################################################################################################################################
    inlet
    {
	
    	type codedFixedValue;
        value uniform (0 0 0.21);//keep this so we see where U value comes from.
        name inlet_rampedU_w_pLimiter;// name of this BC for compiling and dir
        codeOptions
        #{
            -I$(LIB_SRC)/finiteVolume/lnInclude \
            -I$(LIB_SRC)/meshTools/lnInclude
        #};
        codeInclude
        #{
            #include "fvCFD.H"
            #include <cmath>
            #include <iostream>
            #include <fstream>
            #include <string>
            #include <regex>
            #include <chrono>
            #include <dirent.h>
            #include <sys/stat.h>
            #include <string>
            #include <deque>
            #include <vector>
            #include <iostream>
            #include <algorithm>
            
            std::string findNewestFile(const std::string& folder)// finds newest file in folder beginning with "myCustomSolver"
            {
                DIR* dir = opendir(folder.c_str());
                if (!dir) return "";
            
                std::string newestFile;
                time_t newestTime = 0;
            
                struct dirent* entry;
                while ((entry = readdir(dir)) != NULL)
                {
                    std::string fname(entry->d_name);
                    if (fname.find("myCustomSolver") == 0)
                    {
                        std::string fullpath = folder + "/" + fname;
                        struct stat s;
                        if (stat(fullpath.c_str(), &s) == 0)
                        {
                            if (S_ISREG(s.st_mode)) // regular file check
                            {
                                if (s.st_mtime > newestTime)
                                {
                                    newestTime = s.st_mtime;
                                    newestFile = fullpath;
                                }
                            }
                        }
                    }
                }
                closedir(dir);
                return newestFile;
            }

            double extractLastPhaseFraction(const std::string& filename, int maxLines = 80, int bufferSize = 8192)
            // reads actual phaseFraction from log file in /var/tmp
            // does not read every char instead blocks are read backwards
            {
                std::ifstream file(filename, std::ios::binary | std::ios::ate);
                if (!file.is_open())
                    return 0;
            
                std::streamoff fileSize = file.tellg();
                std::streamoff pos = fileSize;
                std::vector<char> buffer(bufferSize);
                std::string leftover;
                std::vector<std::string> lines;
            
                while (pos > 0 && lines.size() < static_cast<size_t>(maxLines))
                {
                    std::streamoff toRead = std::min(pos, static_cast<std::streamoff>(bufferSize));
                    pos -= toRead;
            
                    file.seekg(pos);
                    file.read(buffer.data(), toRead);
            
                    std::string chunk(buffer.data(), toRead);
                    chunk += leftover;
            
                    size_t start = chunk.size();
                    while (start > 0 && lines.size() < static_cast<size_t>(maxLines))
                    {
                        size_t found = chunk.rfind('\n', start - 1);
                        if (found == std::string::npos)
                        {
                            leftover = chunk.substr(0, start);
                            break;
                        }
                        else
                        {
                            lines.push_back(chunk.substr(found + 1, start - found - 1));
                            start = found;
                        }
                    }
                }
            
                std::reverse(lines.begin(), lines.end());
            
                std::regex rgx(R"(Phase-1 volume fraction = ([+-]?[0-9]*\.?[0-9]+([eE][+-]?[0-9]+)?))");
                std::smatch match;
                for (auto it = lines.rbegin(); it != lines.rend(); ++it)
                {
                    if (std::regex_search(*it, match, rgx))
                    {
                        return std::stod(match[1].str());
                    }
                }
                return 0;
            }

            class Timer {//used for timing functions, not actively used here
            private:
                using Clock = std::chrono::steady_clock;
                using Second = std::chrono::duration<double, std::ratio<1>>;
                std::chrono::time_point<Clock> m_beg{ Clock::now() };
            public:
                void reset() { m_beg = Clock::now(); }
                double elapsed() const { return std::chrono::duration_cast<Second>(Clock::now() - m_beg).count(); }
            };            
            
        #};
        
        code
        #{
            //const scalar pressureMax = 1E8; // pressure threshold (Pa) = 1000bar
            //const scalar reductionPercent_pressure = 0.999; // reduce velocity by 0.1% if pressure exceeded
            const scalar reductionPercent_phaseFraction = 0.999; // reduce velocity by 0.1% if phaseFraction >= phaseFraction_finish exceeded
            const scalar phaseFraction_finish = 0.95; // phaseFraction at which we ramp down U in the end.
            const scalar durationRamp = 1E-3; // duration of initial ramping of U (s)
            const fvPatch& boundaryPatch = this->patch();// this patch (inlet)
            const vectorField& Cf = boundaryPatch.Cf();// Center of face
            const scalar t = this->db().time().value();// actual time
            //const volScalarField& pField = this->db().lookupObject<volScalarField>("p_rgh");// pressure_rgh field
            //const fvPatchField<scalar>& pBoundaryField = pField.boundaryField()[boundaryPatch.index()];
            //bool pressureExceeded = false;// bool to check if pressureMax is exceeded
            //scalar nFaceExceededPressure = -10;
            std::string filename = "fool";
            
            filename = findNewestFile("/var/tmp");
            
            double phaseFraction = extractLastPhaseFraction(filename); // WAS VERY SLOW! First version timed at 0.01s 

            vectorField& UPatch = *this;  // current patch velocity values 
            const scalar nFaces = UPatch.size(); // number of faces in this patch, everything here is face centric
            
            vectorField UNew(nFaces);// the new UField we will assign to the faces
            
            scalar counter_rampDuration = 0;
            scalar counter_phaseFraction = 0;
            const scalar initialVelocityz = 0.21;
            const scalar finalVelocityz = 2.1;
            const vector finalVelocity = vector(0, 0, finalVelocityz);
            scalar rampSlope = (finalVelocityz - initialVelocityz) / durationRamp;
            vector initialVelocity = vector(0, 0, initialVelocityz);
            //const vector nullVelocity = vector(0, 0, 0);
            
            // Main loop
            forAll(Cf, i)
            {
                UNew[i] = UPatch[i];// in case we never go into on of the ifs....
                if (t <= durationRamp) // first we ramp up U to finalVelocity in durationRamp
                {
                    vector targetVelocity = vector(0, 0, 1) * rampSlope * t + initialVelocity;
                    UNew[i] = targetVelocity;//--------------
                    if (i==0) //only for the first face, only remove for checking if every face is treated equally.
                    {
                    std::cout << "*****Ramping up U ("<< UNew[i].x() << ", " << UNew[i].y() << ", " << UNew[i].z() << ")" << std::endl << std::flush;
                    }
                }
                else if (t > durationRamp) // after the ramp it's all pressure or phaseFraction controlled
                {
                    if (counter_rampDuration==0) // we need this because we might not hit t=rampDuration exactly, but only execute once for all cells!
                    {
                    UNew[i] = finalVelocity;
                    counter_rampDuration = 1;
                    }

                    //ramp down U when phaseFraction >=0.985 with factor reductionPercent_phaseFraction
                    if (phaseFraction >= phaseFraction_finish && counter_phaseFraction == 0) // reduce U at the end, this is executed more than once in a timeStep, so reductionPercent_phaseFraction must be only a tiny bit below 1.
                    {
                        // Reduce current velocity by factor
                        UNew[i] = UPatch[i] * reductionPercent_phaseFraction;
                        counter_phaseFraction = 1;
                        if (i==0)//only for face0, remove only for checking if every face is treated equally.
                        {
                            std::cout << "-----phaseFraction " << phaseFraction;
                            std::cout << " > " << phaseFraction_finish << ", reducing U to ("<< UNew[i].x() << ", " << UNew[i].y() << ", " << UNew[i].z() << ")";
                            std::cout << std::endl << std::flush;
                        }
                    }
                }
            }
            operator==(UNew);            
        #}; 


    }
//################################################################################################################################################    
    outlet
    {
        type            pressureInletOutletVelocity;
        value           uniform (0 0 -1); // for non-recirculating/supersonic outlet

    }
    solid_to_fluid
    {
        type            slip;
    }
    walls_die
    {
        type fixedValue;
        value uniform (0 0 0);
    }
    fluid_to_solid
    {
        type            slip;
    }
    "proc.*"
    {
        type    processor;
        value   $internalField;
    }
}


// ************************************************************************* //
